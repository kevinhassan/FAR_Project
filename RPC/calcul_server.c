/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calcul.h"
#include <string.h>
#include "encryptment/aes256.h"
#include "encryptment/b64.h"
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#define BLOCK_SIZE 128
int nbBallons = 4;
char* ballons[4];
char* robots[4];

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //NOus serviras a realiser l'exclusion
static reponse result; //la reponse a envoyer à notre client

/**Fonction de cryptage du ballon**/
char* cryptBallon(uchar in[BLOCK_SIZE]){
    uchar out[BLOCK_SIZE];
    Encrypt(in, out);//ecb encode
    char* ch = b64_encode(out, strlen(out));
    return ch;
}

/**Fonction de decryptage du ballon**/
char* decryptBallon(char* ch){
    uchar* in2 = b64_decode(ch, strlen(ch));
    Decrypt(in2, in2);
    return in2;
}
/**Cette fonction vérifie si un robot est dans le tableau des robots auquel on a donné un ballon. Si c'est le cas on ne lui donneras pas de nouveau ballon**/
int estPresentRobot(char* idRobot){
    int present = 0; //Booleen retourné
    int i = 0;
    while(!present && i<4){
        if(robots[i]!=NULL) {
            if(strcmp(robots[i],idRobot)==0){
                present = 1;
            }
        }
        i++;
    }
    return present;
}

/**Procédure principale nous permettant de réaliser l'exclusion mutuelle lors de l'allocation des ballons à un robot**/
void* thread_1(char* arg){
    printf("Nombre de ballon avant de donner: %d\n", nbBallons);
    pthread_mutex_lock (&mutex);
    int i = 0;
    if(nbBallons>0 && !estPresentRobot(arg)){//verifie si il reste des ballons a délivrer.
        char* ballon = cryptBallon(arg);
        int insere = 0;
        while(i<4 && !insere){
            if(ballons[i]==NULL){
                ballons[i] = (char*) malloc(strlen(ballon)+1);
                ballons[i]=ballon;//stocker les ballons
                insere = 1;
                i--;
            }
            i++;
        }
        printf("le ballon est %s",ballons[i]);
        robots[i] = (char*) malloc(strlen(arg)+1);
        strcpy(robots[i],arg);//stocker les robots

        nbBallons = nbBallons-1; //On enlève un ballon
        printf("Nombre de ballon après avoir donné: %d\n", nbBallons);

        result.ballon = ballon; //on sauvegarde la clé pour la renvoyer
        result.errno = 0;
    }else{
        printf("%s","Impossible de donner un ballon\n");
        result.errno = -1;
    }
    pthread_mutex_unlock (&mutex);
    pthread_exit ((void*)0);
}

/**Gestion des threads**/
reponse *
calcul_my_strcat_1_svc(data *argp, struct svc_req *rqstp)
{
    pthread_t thread;
    pthread_create (&thread, NULL, thread_1, argp->arg1);
    pthread_join(thread, NULL);
    return &result;
}

/**Fonction pour valider un ballon lorqu'un validateur de but le demande**/
reponse *
valid_but_1_svc(data *argp, struct svc_req *rqstp)
{
    char* ballon;
    int present = 0;
    int i = 0;

    while(!present && i<4){
        if(ballons[i]!=NULL) {
            if(strcmp(ballons[i],argp->arg1)==0){
                present = 1;
                ballons[i]=NULL;
                robots[i]=NULL;
                nbBallons+=1;
            }
        }
        i++;
    }
    if(present){
        result.ballon="";
        result.errno=0;
    }else{
        result.ballon="";
        result.errno=-1;
    }
    return &result;
}