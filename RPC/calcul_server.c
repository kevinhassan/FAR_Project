/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calcul.h"
#include <string.h>
#include "encryptment/aes256.h"
#include "encryptment/b64.h"
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#define BLOCK_SIZE 128
int nbBallons = 4;
char* ballons[4];
char* robots[4];

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
static reponse result;

char* cryptBallon(uchar in[BLOCK_SIZE]){
    uchar out[BLOCK_SIZE];
    Encrypt(in, out);//ecb encode
    char* ch = b64_encode(out, strlen(out));
    return ch;
}
char* decryptBallon(char* ch){
    uchar* in2 = b64_decode(ch, strlen(ch));
    Decrypt(in2, in2);
    return in2;
}
int estPresent(char* idRobot){
    int present = 0;
    int i = 0;
    while(!present && i<4){
        if(robots[i]!=NULL) {
            if(strcmp(robots[i],idRobot)==0){
                present = 1;
            }
        }
        i++;
    }
    return present;
}

void* thread_1(char* arg){
    printf("Nombre de ballon avant de donner: %d\n", nbBallons);
    pthread_mutex_lock (&mutex);

    if(nbBallons>0 && !estPresent(arg)){
        char* ballon = cryptBallon(arg);
        ballons[4-nbBallons] = (char*) malloc(strlen(ballon)+1);
        strcpy(ballons[4-nbBallons],ballon);//stocker les ballons
        robots[4-nbBallons] = (char*) malloc(strlen(arg)+1);
        strcpy(robots[4-nbBallons],arg);//stocker les ballons

        nbBallons = nbBallons-1; //On enlève un ballon
        printf("Nombre de ballon après avoir donné: %d\n", nbBallons);

        result.ballon = ballon; //on sauvegarde la clé pour la renvoyer
        result.errno = 0;
    }else{
        printf("%s","Impossible de donner un ballon\n");
        result.errno = -1;
    }
    pthread_mutex_unlock (&mutex);
    pthread_exit ((void*)0);
}

reponse *
calcul_my_strcat_1_svc(data *argp, struct svc_req *rqstp)
{
    pthread_t thread;
    pthread_create (&thread, NULL, thread_1, argp->arg1);
    pthread_join(thread, NULL);
    return &result;
}
reponse *
valid_but_1_svc(data *argp, struct svc_req *rqstp)
{

    return &result;
}