/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc_semaphore.h"
#include "rpc_semaphore_xdr.c"
#include <stdio.h>
#include <stdlib.h>
#include <sys/queue.h>
#include <string.h>
#include <arpa/inet.h>
#include "callback_client.c"

static int sem_val = 4;
static int dbg = 1; //true
static int global_counter = 4;
TAILQ_HEAD(tailhead, entry) head;

struct entry {
	char *client_addr;
	int requested_amount;
	int client_id;
	TAILQ_ENTRY(entry) entries;
};

void add_to_queue(int amount, int client_id, const char *client_addr) {
	struct entry *elem;
	elem = malloc(sizeof(struct entry));
	if (elem) {
		elem->requested_amount = amount;
		elem->client_addr = strdup(client_addr);
		elem->client_id = client_id;
	}
	TAILQ_INSERT_TAIL(&head, elem, entries);
}

void remove_head() {
	if (head.tqh_first != NULL) {
		free(head.tqh_first->client_addr);
		TAILQ_REMOVE(&head, head.tqh_first, entries);
	}
}

void pop_if() {
	if (head.tqh_first != NULL && sem_val > head.tqh_first->requested_amount) {
		sem_val -= head.tqh_first->requested_amount;
		if (dbg) {
			printf("Envoyé au client %s\n", head.tqh_first->client_addr);
			printf("Nb ballon restants: %d\n",sem_val-1);
		}
		callback_semaphore_1(head.tqh_first->client_addr, head.tqh_first->client_id);
		remove_head();
	}
	//else {
	//	printf("failed to remove head\n");
	//}
}


int *
up_1_svc(int_and_counter_t *argp, struct svc_req *rqstp)
{
	static int  result;

	if (argp->server_counter < global_counter) {
		result = -1;
		return &result;
	}
	if(sem_val>=global_counter){
		printf("Erreur tous les ballons sont deja présents. Nb ballons disponibles: %d\n", sem_val-1);
	}else{
		sem_val += argp->amount;
		if (dbg) printf("Ballon rentré. Nb ballons disponibles: %d\n", sem_val-1);
	}

	result = 0;
	return &result;
}

int *
down_1_svc(down_arg_t *argp, struct svc_req *rqstp)
{
	static int  result;

	if (argp->server_counter < global_counter) {
		result = -1;
		return &result;
	}
	//if (dbg) printf("^down^ before: %d\n", sem_val);
	//if (sem_val >= *argp)
	//sem_val -= *argp;
	char buf[INET_ADDRSTRLEN];
	add_to_queue(argp->amount, argp->client_id, inet_ntop(AF_INET, &rqstp->rq_xprt->xp_raddr.sin_addr.s_addr, buf, sizeof(buf)));
	//if (dbg) printf("^down^ after: %d\n", sem_val);


	result = 0;
	return &result;
}

int *
set_1_svc(int_and_counter_t *argp, struct svc_req *rqstp)
{
	static int  result;

	if (argp->server_counter < global_counter) {
		result = -1;
		return &result;
	}
	if (dbg) printf("^set^ before: %d\n", sem_val);
	sem_val = argp->amount;
	if (dbg) printf("^set^ after: %d\n", sem_val);

	return &result;
}

int *
get_server_counter_1_svc(int *argp, struct svc_req *rqstp)
{
	return &global_counter;
}
